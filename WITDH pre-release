# WITDH Under Construction 0.3
# Version Notes:

# Import
import pygame
from pygame.locals import *
import sys
import csv
import math
import random
pygame.init()
FPS = 60
fpsClock = pygame.time.Clock()
running = 1

# Constants
Black = (0,0,0)
White = (255,255,255)
Red = (255, 0, 0)
Blue = (0, 0, 255)
Yellow = (255, 255, 0)

textFont = pygame.font.Font(None, 60)

# App Variables
clock = pygame.time.Clock() 
appState = "start pos" # Controls what the user is currently doing
selectedIndex = -1 # Index of the point that the user has selected
textboxText = ""
announcementText = ""

# Screen Setup
screenWidth = 1000
screenHeight = 660
screen = pygame.display.set_mode((screenWidth,screenHeight))
screen.fill(White)
pygame.display.update()

# Textboxes
tfInputTextBox = Rect((screenWidth/2)-250,screenHeight-60,500,50)

tfTextBox = Rect((screenWidth/2)-125,screenHeight-60,250,50)
xVeloTextBox = Rect(60,screenHeight-60,250,50)
xPosTextBox = Rect(60,screenHeight-120,250,50)
yVeloTextBox = Rect(screenWidth-310,screenHeight-60,250,50)
yPosTextBox = Rect(screenWidth-310,screenHeight-120,250,50)

# Trajectory Variables
tf = [] # Time it takes to complete the motion

xPos = [] # x position
xVelo = [] # x velocity at the point

yPos = [] # y position
yVelo = [] # y velocity at the point

def generateTrajectory():
    screen.fill(White)
    cPose = 0
    # Drawing the starting point
    if len(xPos) > 0:
        pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
    while cPose < len(tf):
        # Setting up variables
        x0 = xPos[cPose]
        xf = xPos[cPose + 1]
        xV0 = xVelo[cPose]
        xVf = xVelo[cPose + 1]

        y0 = yPos[cPose]
        yf = yPos[cPose + 1]
        yV0 = yVelo[cPose]
        yVf = yVelo[cPose + 1]

        pygame.draw.line(screen, Red, (xf,yf),(xf+xVf,yf+yVf))

        # Trajectory Generation Setup
        xA = x0
        xB = xV0
        xC = ((3 * (xf - x0))/(tf[cPose]**2)) - (((2 * xV0) + xVf)/tf[cPose])
        xD = -1*((2 * (xf - x0))/(tf[cPose]**3)) + ((xV0 + xVf)/(tf[cPose]**2))

        yA = y0
        yB = yV0
        yC = ((3 * (yf - y0))/(tf[cPose]**2)) - (((2 * yV0) + yVf)/tf[cPose])
        yD = -1*((2 * (yf - y0))/(tf[cPose]**3)) + ((yV0 + yVf)/(tf[cPose]**2))

        t = 0
        while t <= tf[cPose]:
            # Cubic Trajectory Generation 
            xP = xA + (xB * t) + (xC * (t**2)) + (xD * (t**3))
            yP = yA + (yB * t) + (yC * (t**2)) + (yD * (t**3))
            pygame.draw.circle(screen, (0, 0, 0), (xP, yP), 1)
            t += 0.005
        # Drawing the points
        pygame.draw.circle(screen, (0, 0, 0), (xf, yf), 5)
        cPose += 1
    pygame.display.update()

def drawTextbox(textbox, text):
    pygame.draw.rect(screen, Black, textbox, 2)
    screen.blit(textFont.render(str(text), False, Black),  (textbox.x + 5, textbox.y + 5))
    pygame.display.flip()    

def drawAllTextboxes():
    drawTextbox(tfTextBox, tf[selectedIndex-1])
    drawTextbox(xVeloTextBox, xVelo[selectedIndex])
    drawTextbox(xPosTextBox, xPos[selectedIndex])
    drawTextbox(yVeloTextBox, yVelo[selectedIndex])
    drawTextbox(yPosTextBox, yPos[selectedIndex])

while running:
    for event in pygame.event.get():
        # Key press
        if event.type == pygame.KEYDOWN:
            # Textboxes
            if appState == "set tf":
                if event.key == pygame.K_RETURN:
                    try:
                        tf.append(int(textboxText))
                        textboxText = ""
                        generateTrajectory()
                        appState = "new pos"
                    except:
                        textboxText = "Input a number"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                    generateTrajectory()
                    pygame.draw.circle(screen, (0, 0, 0), (mouseClickX, mouseClickY), 5)
                    pygame.draw.line(screen, Red, (mouseClickX,mouseClickY),(mouseReleaseX,mouseReleaseY))
                    pygame.draw.rect(screen, Black, tfInputTextBox, 2)
                else:
                    textboxText += event.unicode
                screen.blit(textFont.render(textboxText, False, Black),  (tfInputTextBox.x + 5, tfInputTextBox.y + 5))
                pygame.display.flip()
            elif appState == "edit tf":
                if event.key == pygame.K_RETURN:
                    appState = "selected point"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                else:
                    textboxText += event.unicode
                try:
                    if int(textboxText) > 0:
                        tf[selectedIndex-1] = int(textboxText)
                except:
                    announcementText = "Please Input a Number"
                generateTrajectory()
                if textboxText != str(tf[selectedIndex-1]):
                    tf[selectedIndex-1] = textboxText
                    drawAllTextboxes()
                    tf[selectedIndex-1] = 1
                else:
                    drawAllTextboxes()
            elif appState == "edit xVelo":
                if event.key == pygame.K_RETURN:
                    appState = "selected point"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                else:
                    textboxText += event.unicode
                try:
                    xVelo[selectedIndex] = int(textboxText)
                except:
                    announcementText = "Please Input a Number"
                generateTrajectory()
                if textboxText != str(xVelo[selectedIndex]):
                    xVelo[selectedIndex] = textboxText
                    drawAllTextboxes()
                    xVelo[selectedIndex] = 0
                else:
                    drawAllTextboxes()
            elif appState == "edit xPos":
                if event.key == pygame.K_RETURN:
                    appState = "selected point"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                else:
                    textboxText += event.unicode
                try:
                    xPos[selectedIndex] = int(textboxText)
                except:
                    announcementText = "Please Input a Number"
                generateTrajectory()
                if textboxText != str(xPos[selectedIndex]):
                    xPos[selectedIndex] = textboxText
                    drawAllTextboxes()
                    xPos[selectedIndex] = 0
                else:
                    drawAllTextboxes()
            elif appState == "edit yVelo":
                if event.key == pygame.K_RETURN:
                    appState = "selected point"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                else:
                    textboxText += event.unicode
                try:
                    yVelo[selectedIndex] = int(textboxText)
                except:
                    announcementText = "Please Input a Number"
                generateTrajectory()
                if textboxText != str(yVelo[selectedIndex]):
                    yVelo[selectedIndex] = textboxText
                    drawAllTextboxes()
                    yVelo[selectedIndex] = 0
                else:
                    drawAllTextboxes()
            elif appState == "edit yPos":
                if event.key == pygame.K_RETURN:
                    appState = "selected point"
                elif event.key == pygame.K_BACKSPACE:
                    textboxText = textboxText[:-1]
                else:
                    textboxText += event.unicode
                try:
                    yPos[selectedIndex] = int(textboxText)
                except:
                    announcementText = "Please Input a Number"
                generateTrajectory()
                if textboxText != str(yPos[selectedIndex]):
                    yPos[selectedIndex] = textboxText
                    drawAllTextboxes()
                    yPos[selectedIndex] = 0
                else:
                    drawAllTextboxes()
            # Sets the mode to adding new points
            elif event.key == pygame.K_q:
                appState = "new pos"
            # Sets the mode to editing points
            elif event.key == pygame.K_e or (event.key == pygame.K_ESCAPE and appState == "selected point"):
                selectedIndex = -1
                appState = "edit points"
                generateTrajectory()
            # Removes the selected point
            elif event.key == pygame.K_z and appState == "selected point":
                xPos.pop(selectedIndex)
                yPos.pop(selectedIndex)
                xVelo.pop(selectedIndex)
                yVelo.pop(selectedIndex)
                if selectedIndex > 0:
                    tf.pop(selectedIndex-1)
                elif len(tf) > 0:
                    tf.pop(0)
                generateTrajectory()
                selectedIndex = -1
                appState = "edit points"
        # Mouse Click
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouseClickX, mouseClickY = pygame.mouse.get_pos()
            # Resets appState if the position list is empty
            if len(xPos) == 0:
                appState = "start pos"
            # Adding the starting point
            if appState == "start pos":
                xPos.append(mouseClickX)
                xVelo.append(0)
                yPos.append(mouseClickY)
                yVelo.append(0)
                pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
                pygame.display.update()
            # Adds the location of new points to the position lists
            elif appState == "new pos":
                xPos.append(mouseClickX)
                yPos.append(mouseClickY)
                pygame.draw.circle(screen, (0, 0, 0), (mouseClickX, mouseClickY), 5)
                pygame.display.update()
            # In edit mode, checks if the mouse has clicked on any point
            elif appState == "edit points":
                counter = 0
                while selectedIndex == -1 and counter < len(xPos):
                    if xPos[counter] - 5 < mouseClickX < xPos[counter] + 5 and yPos[counter] - 5 < mouseClickY < yPos[counter] + 5:
                        # Sets selectedIndex to the point that the mouse clicked
                        selectedIndex = counter
                        appState = "selected point"
                        # Adds the textboxes for editing the point
                        drawAllTextboxes()
                    counter += 1
            # Ways to interact with the selected point
            elif appState == "selected point":
                # Starts dragging a point
                if xPos[selectedIndex] - 5 < mouseClickX < xPos[selectedIndex] + 5 and yPos[selectedIndex] - 5 < mouseClickY < yPos[selectedIndex] + 5:
                    appState = "moving point"
                # Editing points
                elif pygame.Rect.collidepoint(tfTextBox, (event.pos)):
                    appState = "edit tf"
                    textboxText = str(tf[selectedIndex-1])
                elif pygame.Rect.collidepoint(xVeloTextBox, (event.pos)):
                    appState = "edit xVelo"
                    textboxText = str(xVelo[selectedIndex])
                elif pygame.Rect.collidepoint(xPosTextBox, (event.pos)):
                    appState = "edit xPos"
                    textboxText = str(xPos[selectedIndex])
                elif pygame.Rect.collidepoint(yVeloTextBox, (event.pos)):
                    appState = "edit yVelo"
                    textboxText = str(xVelo[selectedIndex])
                elif pygame.Rect.collidepoint(yPosTextBox, (event.pos)):
                    appState = "edit yPos"
                    textboxText = str(yPos[selectedIndex])
        # Mouse Release
        if event.type == pygame.MOUSEBUTTONUP:
            mouseReleaseX, mouseReleaseY = pygame.mouse.get_pos()
            # Swaps out of the start pos state after it's created
            if appState == "start pos":
                appState = "new pos"
            # Adds the velocity of the new points to the velocity lists
            elif appState == "new pos":
                xVelo.append(mouseReleaseX - mouseClickX)
                yVelo.append(mouseReleaseY - mouseClickY)
                textboxText = ""
                appState = "set tf"
                pygame.draw.line(screen, Red, (mouseClickX,mouseClickY),(mouseReleaseX,mouseReleaseY))
                pygame.draw.rect(screen, Black, tfInputTextBox, 2)
                pygame.display.update()
            # Stops dragging a point
            elif appState == "moving point":
                appState = "selected point"
                drawAllTextboxes()
        # The actuall point dragging code
        if event.type == pygame.MOUSEMOTION:
            if appState == "moving point":
                xPos[selectedIndex] = event.pos[0]
                yPos[selectedIndex] = event.pos[1]
                generateTrajectory()
        # Exit
        if event.type == pygame.QUIT:
            running=0
    clock.tick(60) 
pygame.quit()