# WITDH Under Construction 1.2
# Version Notes:

# Import
import pygame
from pygame.locals import *
import sys
import csv
import math
import random
pygame.init()
FPS = 60
fpsClock = pygame.time.Clock()
running = 1

# Constants
Black = (0,0,0)
White = (255,255,255)
Red = (255, 0, 0)
Blue = (0, 0, 255)
Yellow = (255, 255, 0)

textFont = pygame.font.Font(None, 32)

# App Variables
appState = "start pos" # Controls what the user is currently doing
selectedIndex = -1 # Index of the point that the user has selected
textboxText = ""

# Screen Setup
screenWidth = 1000
screenHeight = 660
screen = pygame.display.set_mode((screenWidth,screenHeight))
screen.fill(White)
pygame.display.update()

tfTextBox = Rect((screenWidth/2)-250,screenHeight-60,500,50)

# Trajectory Variables
tf = [] # Time it takes to complete the motion

xPos = [] # x position
xVelo = [] # x velocity at the point

yPos = [] # y position
yVelo = [] # y velocity at the point

def generateTrajectory():
    screen.fill(White)
    cPose = 0
    # Drawing the starting point
    if len(xPos) > 0:
        pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
    while cPose < len(xPos) - 1:
        # Setting up variables
        x0 = xPos[cPose]
        xf = xPos[cPose + 1]
        xV0 = xVelo[cPose]
        xVf = xVelo[cPose + 1]

        y0 = yPos[cPose]
        yf = yPos[cPose + 1]
        yV0 = yVelo[cPose]
        yVf = yVelo[cPose + 1]

        pygame.draw.line(screen, Red, (xf,yf),(xf+xVf,yf+yVf))

        # Trajectory Generation Setup
        xA = x0
        xB = xV0
        xC = ((3 * (xf - x0))/(tf[cPose]**2)) - (((2 * xV0) + xVf)/tf[cPose])
        xD = -1*((2 * (xf - x0))/(tf[cPose]**3)) + ((xV0 + xVf)/(tf[cPose]**2))

        yA = y0
        yB = yV0
        yC = ((3 * (yf - y0))/(tf[cPose]**2)) - (((2 * yV0) + yVf)/tf[cPose])
        yD = -1*((2 * (yf - y0))/(tf[cPose]**3)) + ((yV0 + yVf)/(tf[cPose]**2))

        t = 0
        while t <= tf[cPose]:
            # Cubic Trajectory Generation 
            xP = xA + (xB * t) + (xC * (t**2)) + (xD * (t**3))
            yP = yA + (yB * t) + (yC * (t**2)) + (yD * (t**3))
            pygame.draw.circle(screen, (0, 0, 0), (xP, yP), 1)
            t += 0.005
        # Drawing the points
        pygame.draw.circle(screen, (0, 0, 0), (xf, yf), 5)
        cPose += 1
    pygame.display.update()

while running:
    for event in pygame.event.get():
        # Key press
        if event.type == pygame.KEYDOWN:
            if appState == "set tf":
                screen.blit(textFont.render(textboxText, True, Black))
            # Sets the mode to adding new points
            elif event.key == pygame.K_q:
                appState = "new pos"
            # Sets the mode to editing points
            elif event.key == pygame.K_e or (event.key == pygame.K_ESCAPE and appState == "selected point"):
                selectedIndex = -1
                appState = "edit points"
            # Removes the selected point
            elif event.key == pygame.K_z and appState == "selected point":
                xPos.pop(selectedIndex)
                yPos.pop(selectedIndex)
                xVelo.pop(selectedIndex)
                yVelo.pop(selectedIndex)
                if selectedIndex > 0:
                    tf.pop(selectedIndex-1)
                elif len(tf) > 0:
                    tf.pop(0)
                generateTrajectory()
                selectedIndex = -1
                appState = "edit points"
        # Mouse Click
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouseClickX, mouseClickY = pygame.mouse.get_pos()
            # Resets appState if the position list is empty
            if len(xPos) == 0:
                appState = "start pos"
            # Adding the starting point
            if appState == "start pos":
                xPos.append(mouseClickX)
                xVelo.append(0)
                yPos.append(mouseClickY)
                yVelo.append(0)
                pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
                pygame.display.update()
            # Adds the location of new points to the position lists
            elif appState == "new pos":
                xPos.append(mouseClickX)
                yPos.append(mouseClickY)
                tf.append(random.randint(2,8))
                pygame.draw.rect(screen, Black, tfTextBox, 2)
                appState = "set tf"
            # In edit mode, checks if the mouse has clicked on any point
            elif appState == "edit points":
                counter = 0
                while selectedIndex == -1 and counter < len(xPos):
                    if xPos[counter] - 5 < mouseClickX < xPos[counter] + 5 and yPos[counter] - 5 < mouseClickY < yPos[counter] + 5:
                        # Sets selectedIndex to the point that the mouse clicked
                        selectedIndex = counter
                        appState = "selected point"
                    counter += 1
            # Starts dragging a point
            elif appState == "selected point" and xPos[selectedIndex] - 5 < mouseClickX < xPos[selectedIndex] + 5 and yPos[selectedIndex] - 5 < mouseClickY < yPos[selectedIndex] + 5:
                appState = "moving point"
        # Mouse Release
        if event.type == pygame.MOUSEBUTTONUP:
            mouseReleaseX, mouseReleaseY = pygame.mouse.get_pos()
            # Swaps out of the start pos state after it's created
            if appState == "start pos":
                appState = "new pos"
            # Adds the velocity of the new points to the velocity lists
            elif appState == "new pos":
                xVelo.append(mouseReleaseX - mouseClickX)
                yVelo.append(mouseReleaseY - mouseClickY)
                generateTrajectory()
            # Stops dragging a point
            elif appState == "moving point":
                appState = "selected point"
        # The actuall point dragging code
        if event.type == pygame.MOUSEMOTION and appState == "moving point":
            xPos[selectedIndex] = event.pos[0]
            yPos[selectedIndex] = event.pos[1]
            pygame.time.wait(30)
            generateTrajectory()
        # Exit
        if event.type == pygame.QUIT:
            running=0
pygame.quit()