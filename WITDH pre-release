# WITDH Under Construction 1.2
# Version Notes:

# Import
import pygame
from pygame.locals import *
import sys
import csv
import math
import random
pygame.init()
FPS = 60
fpsClock = pygame.time.Clock()
running = 1

# Setup Variables
Black = (0,0,0)
White = (255,255,255)
Red = (255, 0, 0)
Blue = (0, 0, 255)
Yellow = (255, 255, 0)

# App Variables
appState = "start pos"

# Screen Setup
screen = pygame.display.set_mode((700,500))
screen.fill(White)
pygame.display.update()

# Trajectory Variables
tf = []

xPos = []
xVelo = []

yPos = []
yVelo = []

def generateTrajectory():
    screen.fill(White)
    cPose = 0
    pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
    while cPose < len(xPos) - 1:

        x0 = xPos[cPose]
        xf = xPos[cPose + 1]
        xV0 = xVelo[cPose]
        xVf = xVelo[cPose + 1]

        y0 = yPos[cPose]
        yf = yPos[cPose + 1]
        yV0 = yVelo[cPose]
        yVf = yVelo[cPose + 1]

        pygame.draw.line(screen, Red, (xf,yf),(xf+xVf,yf+yVf))

        # Trajectory Generation Setup
        xA = x0
        xB = xV0
        xC = ((3 * (xf - x0))/(tf[cPose]**2)) - (((2 * xV0) + xVf)/tf[cPose])
        xD = -1*((2 * (xf - x0))/(tf[cPose]**3)) + ((xV0 + xVf)/(tf[cPose]**2))

        yA = y0
        yB = yV0
        yC = ((3 * (yf - y0))/(tf[cPose]**2)) - (((2 * yV0) + yVf)/tf[cPose])
        yD = -1*((2 * (yf - y0))/(tf[cPose]**3)) + ((yV0 + yVf)/(tf[cPose]**2))

        t = 0
        while t <= tf[cPose]:
            # Cubic Trajectory Generation 
            xP = xA + (xB * t) + (xC * (t**2)) + (xD * (t**3))
            yP = yA + (yB * t) + (yC * (t**2)) + (yD * (t**3))
            pygame.draw.circle(screen, (0, 0, 0), (xP, yP), 1)
            t += 0.005
        pygame.draw.circle(screen, (0, 0, 0), (xf, yf), 5)

        pygame.display.update()
        cPose += 1

while running:
    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                appState = "new pos"
            if event.key == pygame.K_e:
                appState = "edit points"
        # Mouse Button Down
        if event.type == pygame.MOUSEBUTTONDOWN:
            mouseClickX, mouseClickY = pygame.mouse.get_pos()
            # Adding the starting point
            if appState == "start pos":
                xPos.append(mouseClickX)
                xVelo.append(0)
                yPos.append(mouseClickY)
                yVelo.append(0)
                pygame.draw.circle(screen, (0, 0, 0), (xPos[0], yPos[0]), 5)
                pygame.display.update()
            # Adds the location of new points to the position lists
            elif appState == "new pos":
                xPos.append(mouseClickX)
                yPos.append(mouseClickY)
                tf.append(random.randint(2,4))
            elif appState == "edit points":
                selectedIndex = -1
                counter = 0
                while selectedIndex == -1 and counter < len(xPos):
                    if xPos[counter] - 5 < mouseClickX < xPos[counter] + 5 and yPos[counter] - 5 < mouseClickY < yPos[counter] + 5:
                        selectedIndex = counter
                        xPos.pop(counter)
                        yPos.pop(counter)
                        xVelo.pop(counter)
                        yVelo.pop(counter)
                        tf.pop(counter-1)
                        generateTrajectory()
                    counter += 1
        # Mouse Button Up
        if event.type == pygame.MOUSEBUTTONUP:
            mouseReleaseX, mouseReleaseY = pygame.mouse.get_pos()
            # Swaps out of the start pos state after it's created
            if appState == "start pos":
                appState = "new pos"
            # Adds the velocity of the new points to the velocity lists
            elif appState == "new pos":
                xVelo.append(mouseReleaseX - mouseClickX)
                yVelo.append(mouseReleaseY - mouseClickY)
                generateTrajectory()
        # Exit
        if event.type == pygame.QUIT:
            running=0
        # Recording the robot starting position
pygame.quit()